1. GÃœN â€“ 11 Temmuz 2025 Cuma
StajÄ±mÄ±n ilk gÃ¼nÃ¼ydÃ¼. Sabah ÅŸirkete giriÅŸ yaptÄ±ktan sonra Ä°nsan KaynaklarÄ± departmanÄ±nda gÃ¶revli Merve HanÄ±m ile staj kabul sÃ¼recine dair evrak iÅŸlemlerini tamamladÄ±m. SGK giriÅŸ bildirgesi, Ã¶ÄŸrenci belgesi, iletiÅŸim ve IBAN bilgilerimi eksiksiz olarak teslim ettim.
Evrak iÅŸlemlerinin ardÄ±ndan kurum iÃ§i kullanÄ±m iÃ§in bir dizÃ¼stÃ¼ bilgisayar teslim aldÄ±m. Ä°lk kurulumlar teknik ekip tarafÄ±ndan yapÄ±ldÄ±. KullanÄ±cÄ± hesabÄ±m ile sisteme giriÅŸ yaptÄ±ktan sonra VPN kullanÄ±mÄ±, gÃ¼venlik prosedÃ¼rleri ve ÅŸirketin teknik destek portalÄ± support.innova.com.tr Ã¼zerinden yardÄ±m talebi oluÅŸturma sÃ¼reÃ§leri bana gÃ¶sterildi.
ArdÄ±ndan Ã§alÄ±ÅŸacaÄŸÄ±m birime geÃ§tim ve bana mentorluk edecek olan Yusuf Bey ile tanÄ±ÅŸtÄ±m. Ä°lk sohbetimizde .NET konusundaki bilgi seviyemden bahsettik. Temel seviyede bilgim olduÄŸunu sÃ¶yledim. Yusuf Bey, bu doÄŸrultuda ilk birkaÃ§ gÃ¼nÃ¼mÃ¼ oryantasyon ve temel teknolojilere hazÄ±rlÄ±k sÃ¼reci olarak planladÄ±.
GÃ¼nÃ¼n teknik kÄ±smÄ±nda geliÅŸtirme ortamÄ±mÄ± kurmaya baÅŸladÄ±k:
â€¢	Visual Studio 2022 Community Edition ve gerekli .NET uzantÄ±larÄ±nÄ± yÃ¼kledik.
â€¢	Microsoft SQL Server 2022 ve SQL Server Management Studio (SSMS) kurulumunu gerÃ§ekleÅŸtirdik.
â€¢	.NET 8 SDK sistemime eklendi.
â€¢	Git kuruldu ve GitHub hesabÄ±m ile baÄŸlantÄ±sÄ± yapÄ±ldÄ±.
Yusuf Bey, staj sÃ¼resince geliÅŸtireceÄŸim projenin GitHub Ã¼zerinde tutulacaÄŸÄ±nÄ± sÃ¶yledi. Projenin adÄ± EInvoice olacak ve Ã§ok katmanlÄ± (N-Tier Architecture) bir yapÄ±da geliÅŸtirilecekti. GÃ¼nÃ¼n sonunda GitHub Ã¼zerinden boÅŸ bir repository oluÅŸturarak bilgisayarÄ±ma klonladÄ±m ve ilk commitâ€™i attÄ±m.
BugÃ¼n herhangi bir daily scrum toplantÄ±sÄ±na katÄ±lmadÄ±m, ancak Yusuf Bey bana bu toplantÄ±larÄ±n her gÃ¼n sabah 09:15â€™te yapÄ±ldÄ±ÄŸÄ±nÄ± ve ertesi gÃ¼nden itibaren benim de katÄ±lacaÄŸÄ±mÄ± sÃ¶yledi. BÃ¶ylece ekipteki diÄŸer kiÅŸilerle tanÄ±ÅŸma fÄ±rsatÄ±m da olacaktÄ±.
Ä°lk gÃ¼nÃ¼m, hem ÅŸirket kÃ¼ltÃ¼rÃ¼nÃ¼ hem de teknik araÃ§larÄ± tanÄ±mam aÃ§Ä±sÄ±ndan Ã§ok verimli geÃ§ti. Bundan sonraki gÃ¼nlerde doÄŸrudan geliÅŸtirme sÃ¼recine geÃ§ebilmek iÃ§in tÃ¼m kurulum ve hazÄ±rlÄ±klarÄ± tamamlamÄ±ÅŸ oldum.
2. GÃœN â€“ 14 Temmuz 2025 Pazartesi
BugÃ¼n gÃ¼ne saat 09:15â€™te ekibin gÃ¼nlÃ¼k daily scrum toplantÄ±sÄ±na katÄ±larak baÅŸladÄ±m. ToplantÄ± ofiste toplantÄ± odasÄ±nda yÃ¼z yÃ¼ze yapÄ±ldÄ±. Ekipteki herkes sÄ±rayla Ã¶nceki gÃ¼n ne yaptÄ±ÄŸÄ±nÄ±, o gÃ¼n ne yapacaÄŸÄ±nÄ± ve varsa karÅŸÄ±laÅŸtÄ±ÄŸÄ± sorunlarÄ± paylaÅŸtÄ±. Bu sayede hem ekibin birbirini sÃ¼rekli gÃ¼ncel tuttuÄŸunu hem de iÅŸlerin dÃ¼zenli bir ÅŸekilde ilerlediÄŸini gÃ¶rdÃ¼m. AyrÄ±ca bu toplantÄ±da ekipteki diÄŸer yazÄ±lÄ±m geliÅŸtiricilerle tanÄ±ÅŸtÄ±m.
Daily toplantÄ±sÄ±nÄ±n ardÄ±ndan mentorÃ¼m Yusuf Bey ile yÃ¼z yÃ¼ze konuÅŸarak staj boyunca Ã¼zerinde Ã§alÄ±ÅŸacaÄŸÄ±m proje konusunu netleÅŸtirdik. Åirket, benden bir E-Fatura ve Finansal YÃ¶netim Sistemi geliÅŸtirmemi istedi. Bu sistem sadece staj Ã§alÄ±ÅŸmasÄ± olarak kalmayacak, aynÄ± zamanda ÅŸirket iÃ§inde demo sÃ¼rÃ¼m olarak kullanÄ±labilecek dÃ¼zeyde olacaktÄ±.
Ã–ÄŸleden sonra projeye baÅŸlamadan Ã¶nce araÅŸtÄ±rma yaptÄ±m. TÃ¼rkiyeâ€™de aktif olarak kullanÄ±lan e-fatura sistemlerini inceledim ve farklÄ± firmalarÄ±n geliÅŸtirdiÄŸi Ã¶rnek projelere gÃ¶z attÄ±m. BÃ¶ylece sistemlerin nasÄ±l Ã§alÄ±ÅŸtÄ±ÄŸÄ±nÄ±, kullanÄ±cÄ±larÄ±n hangi iÅŸlemleri sÄ±klÄ±kla yaptÄ±ÄŸÄ±nÄ± ve ekran tasarÄ±mlarÄ±nÄ±n nasÄ±l kurgulandÄ±ÄŸÄ±nÄ± gÃ¶zlemledim. Ã–zellikle e-fatura sÃ¼reÃ§lerinde dikkatimi Ã§eken baÅŸlÄ±ca konular ÅŸunlar oldu:
â€¢	FaturalarÄ±n satÄ±r bazÄ±nda Ã¼rÃ¼n/hizmet ekleme mantÄ±ÄŸÄ±yla hazÄ±rlanmasÄ±
â€¢	MÃ¼ÅŸteri bilgilerinin faturaya entegre edilmesi
â€¢	Otomatik numaralandÄ±rma ve tarih kontrolÃ¼
â€¢	KullanÄ±cÄ± arayÃ¼zlerinde sade ama iÅŸlevsel menÃ¼ tasarÄ±mlarÄ±
GÃ¼nÃ¼n sonunda, Yusuf Bey ile yaptÄ±ÄŸÄ±mÄ±z gÃ¶rÃ¼ÅŸmede ertesi gÃ¼n proje mimarisini planlamaya baÅŸlayacaÄŸÄ±mÄ±zÄ± kararlaÅŸtÄ±rdÄ±k. BÃ¶ylece iÅŸe baÅŸlamadan Ã¶nce sistemin genel iÅŸleyiÅŸini anlamÄ±ÅŸ ve hedefleri kafamda netleÅŸtirmiÅŸ oldum.
3. GÃœN â€“ 16 Temmuz 2025 Ã‡arÅŸamba
BugÃ¼n, sabah saat 09:15â€™te ofiste gerÃ§ekleÅŸtirilen gÃ¼nlÃ¼k Daily Scrum toplantÄ±sÄ±na katÄ±larak gÃ¼ne baÅŸladÄ±m. ToplantÄ±da bir Ã¶nceki gÃ¼n yaptÄ±ÄŸÄ±m araÅŸtÄ±rmalardan ve proje iÃ§in taslak fikirlerimden bahsettim. AyrÄ±ca bugÃ¼n projenin yazÄ±lÄ±m mimarisi ve temel veri yapÄ±sÄ± olan veritabanÄ± tasarÄ±mÄ±na baÅŸlayacaÄŸÄ±mÄ±z belirtildi. Yusuf Bey, â€œBu sistemde en Ã¶nemli kÄ±sÄ±m veritabanÄ±, Ã¶nce onu saÄŸlam kuralÄ±mâ€ dedi.
Ãœniversitede veritabanÄ± dersi aldÄ±ÄŸÄ±m iÃ§in temel mantÄ±ÄŸÄ±nÄ± biliyordum. Bu yÃ¼zden bilgisayar baÅŸÄ±na geÃ§tiÄŸimde tablolarÄ± Ã¶nce kendim Ã§Ä±karmam, sonrasÄ±nda birlikte kontrol edeceÄŸimiz sÃ¶ylendi. Ana tablolarÄ± yazmaya baÅŸladÄ±m. Genel tablolarÄ± oluÅŸtururken sorun yaÅŸamadÄ±m ancak kullanÄ±cÄ± giriÅŸi iÃ§in ÅŸifre, e-posta gibi alanlarÄ± User tablosuna eklemiÅŸtim. Bu konuda emin olamadÄ±m. Yusuf Bey, bu bilgilerin UserCredential adÄ±nda ayrÄ± bir tabloda tutulmasÄ± gerektiÄŸini anlattÄ±.
Bu tablonun ÅŸifre, giriÅŸ deneme sayÄ±sÄ±, token gibi gÃ¼venlik verilerini barÄ±ndÄ±racaÄŸÄ±nÄ± ve User tablosu ile birebir iliÅŸkili olacaÄŸÄ±nÄ± belirtti. Bunu daha Ã¶nce hiÃ§ yapmadÄ±ÄŸÄ±m iÃ§in Ã¶nce User tablosundan bu alanlarÄ± kaldÄ±rdÄ±m, ardÄ±ndan UserCredential tablosunu ekledim. AraÅŸtÄ±rma sonucunda ÅŸifrelerin hash olarak saklanmasÄ±, token bilgisinin eklenmesi ve son giriÅŸ tarihi gibi detaylarÄ±n gÃ¼venlik aÃ§Ä±sÄ±ndan Ã¶nemli olduÄŸunu Ã¶ÄŸrendim.
OluÅŸturulan tablolar:
â€¢	Person: KiÅŸi bilgileri (ad, TCKN/VKN, vergi dairesi).
â€¢	CustomerSupplier: KiÅŸinin mÃ¼ÅŸteri mi yoksa tedarikÃ§i mi olduÄŸunu tutuyor.
â€¢	Addresses: KiÅŸilerin adresleri. Birden fazla adres eklenebiliyor.
â€¢	ProductsAndServices: ÃœrÃ¼n ve hizmet listesi.
â€¢	Invoices ve LineOfInvoices: Faturalar ve satÄ±rlarÄ±.
â€¢	Currents, Banks, Cases: Finans iÅŸlemleri iÃ§in.
Ä°liÅŸkiler Ã¼zerinde Ã§alÄ±ÅŸÄ±rken tablolarÄ±n birbirine nasÄ±l baÄŸlanacaÄŸÄ±nÄ± netleÅŸtirdik. User ile UserCredential birebir (1-1), User ile Person birebir (1-1), Invoice ile LineOfInvoices bire Ã§ok (1-N) iliÅŸkili olacak ÅŸekilde tasarlandÄ±. CustomerSupplier â€“ Person ve Addresses â€“ Person iliÅŸkileri bire Ã§ok (1-N) olacak. Banks ile Currents ve Cases ile Currents ise birebir (1-1) olacak.
AyrÄ±ca veri bÃ¼tÃ¼nlÃ¼ÄŸÃ¼nÃ¼ saÄŸlamak ve yanlÄ±ÅŸ veri giriÅŸlerini Ã¶nlemek iÃ§in Foreign Keyâ€™lerin doÄŸru tanÄ±mlanmasÄ±nÄ±n Ã¶nemi Ã¼zerinde durduk.
[ER diyagramÄ± gÃ¶rseli buraya eklenecek]
GÃ¼nÃ¼n sonunda tÃ¼m tablolarÄ±n ve iliÅŸkilerin yer aldÄ±ÄŸÄ± ER diyagramÄ± tamamlandÄ±. Bu sÃ¼reÃ§te UserCredential tablosu benim iÃ§in en yeni ve Ã¶ÄŸretici kÄ±sÄ±m oldu. BaÅŸlangÄ±Ã§ta kullanÄ±cÄ± giriÅŸi iÃ§in gerekli alanlarÄ± User tablosuna eklemiÅŸtim. Yusuf Beyâ€™in yÃ¶nlendirmesiyle bu alanlarÄ± ayrÄ± bir tabloda toplamanÄ±n mantÄ±ÄŸÄ±nÄ± Ã¶ÄŸrenmiÅŸ oldum.

4. GÃœN â€“ 17 Temmuz 2025 PerÅŸembe
Sabah dailyâ€™de dÃ¼nkÃ¼ ER yapÄ±sÄ±nÄ± kÄ±saca hatÄ±rlattÄ±m. BugÃ¼n, veri tabanÄ± ÅŸemasÄ±nÄ± kod tarafÄ±na yansÄ±tmak iÃ§in entity altyapÄ±sÄ±nÄ± hazÄ±rlamaya baÅŸladÄ±m. TÃ¼m entitilerde ortak olan alanlarÄ± her sÄ±nÄ±fa tek tek yazmak yerine BaseEntity altÄ±nda topladÄ±m ve tÃ¼m entityâ€™lerin bu sÄ±nÄ±ftan kalÄ±tÄ±m almasÄ±nÄ± saÄŸladÄ±m. BÃ¶ylece kod tekrarÄ±nÄ± Ã¶nledim, standardÄ± korudum; ÅŸirketin benimsediÄŸi SOLID prensiplerine uygun, okunabilir, sÃ¼rdÃ¼rÃ¼lebilir, bakÄ±mÄ± kolay ve geniÅŸletilebilir bir temel elde ettim.
Projede klasÃ¶r yapÄ±lanmasÄ±nÄ± da netleÅŸtirdim: Entities ve Enumerations klasÃ¶rlerini ayÄ±rdÄ±m (Resim 1.2â€™de gÃ¶rÃ¼lmektedir). â€œTipâ€ niteliÄŸi taÅŸÄ±yan alanlar iÃ§in enum kullanacaÄŸÄ±m; bu yaklaÅŸÄ±m hem standartlara uyuyor hem de magic number kullanÄ±mÄ±nÄ± engelliyor.
 
BaseEntity (ortak alanlar)
â€¢	Id
â€¢	CreatedDate
â€¢	UpdatedDate
â€¢	Status (aktif/pasif)
BaseEntity kodu:
csharp
CopyEdit
namespace DatabaseAccessLayer.Models
{
    public abstract class BaseEntity
    {
        public long Id { get; set; }
        public DateTime CreatedDate { get; set; } = DateTime.Now;
        public DateTime? UpdatedDate { get; set; }
        public Status Status { get; set; }
    }
}
Enum setleri (kullanÄ±m amacÄ±)
â€¢	Status (Active/Passive)
â€¢	AddressType (Email, Åube, Fax, Phone, WebSite)
â€¢	CurrencyType (TL, EUR, USD)
â€¢	CurrentType (Case, Bank)
â€¢	CustomerOrSupplierType (Customer, Supplier)
â€¢	InvoiceSenario (EInvoice, EArchive, Paper)
â€¢	InvoiceType (Purchase, Sales)
â€¢	PersonType (User, CustomerOrSupplier)
â€¢	UnitType (Adet, Kilogram, Gram, Litre, Mililitre, Metre, Santimetre)
â€¢	UserType (NaturalPerson, LegalEntity)
Entityâ€™lerde kullanÄ±m Ã¶rneÄŸi
Entityâ€™lerde BaseEntityâ€™yi bu ÅŸekilde kullanacaÄŸÄ±m:
csharp
CopyEdit
public class Address : BaseEntity
{
    public AddressType AddressType { get; set; }

    [Required]
    [MaxLength(200)]
    public string Text { get; set; }

    public long PersonId { get; set; }

    [ForeignKey("PersonId")]
    public Person Person { get; set; }
}
GÃ¼nÃ¼n sonunda BaseEntity ve tÃ¼m enum yapÄ±larÄ± tamamlandÄ±; klasÃ¶r dÃ¼zeni oturdu (Resim 1.2). YarÄ±n, ÅŸemaya gÃ¶re tÃ¼m entity sÄ±nÄ±flarÄ±nÄ± bu standartla yazÄ±p bitireceÄŸim.
5. GÃœN â€“ 18 Temmuz 2025 Cuma
Dailyâ€™de, dÃ¼nkÃ¼ veritabanÄ± ÅŸema Ã§alÄ±ÅŸmalarÄ±nÄ±n ardÄ±ndan bugÃ¼n entity sÄ±nÄ±flarÄ±nÄ± yazdÄ±ÄŸÄ±mÄ± paylaÅŸtÄ±m.
TÃ¼m entityâ€™lerde daha Ã¶nce oluÅŸturduÄŸum enum tiplerini (AddressType, UserType, CustomerOrSupplierType, CurrencyType, PersonType, InvoiceType, InvoiceSenario, UnitType) kullandÄ±m.
BaseEntity sÄ±nÄ±fÄ±ndan kalÄ±tÄ±m alarak Id, CreatedDate, UpdatedDate, Status gibi ortak alanlarÄ± her entityâ€™de otomatik hale getirdim.
Ä°liÅŸkileri entity tarafÄ±nda Data Annotations ile tanÄ±mladÄ±m:
â€¢	[Required] â†’ Zorunlu alan
â€¢	[MaxLength] â†’ Maksimum uzunluk
â€¢	[ForeignKey] â†’ FK tanÄ±mÄ±
â€¢	[Column(TypeName = "decimal(18,2)")] â†’ OndalÄ±k hassasiyet
BugÃ¼n ayrÄ±ca, bire-bir (1-1), bire-Ã§ok (1-N) ve Ã§oktan-bire (N-1) iliÅŸkilerin entity tarafÄ±nda nasÄ±l yazÄ±ldÄ±ÄŸÄ±nÄ± inceledim ve uyguladÄ±m.
 
1ï¸âƒ£ Bire-bir (One-to-One) Ä°liÅŸki
TanÄ±m:
Her iki tarafta da tekil navigation bulunur, FK baÄŸÄ±mlÄ± tarafta olur. Genelde FK alanÄ± unique olmalÄ±dÄ±r.
Ã–rneÄŸim: User â†” UserCredential
Elle yazdÄ±ÄŸÄ±m kod:
public class UserCredential : BaseEntity
{
    public long UserId { get; set; } // User ile 1-1 iliÅŸki

    public string Provider { get; set; } = "Local";
    public string Email { get; set; } = null!;
    public string PasswordHash { get; set; } = null!;
    public string? SecurityStamp { get; set; }

    public User User { get; set; } = null!;
}
Bu yapÄ±da User ile UserCredential arasÄ±nda bire-bir iliÅŸki kuruldu. Resim 1.1â€™de gÃ¶rÃ¼lmektedir.
 
2ï¸âƒ£ Bire-Ã§ok (One-to-Many) Ä°liÅŸki
TanÄ±m:
Ãœst entity koleksiyon tutar, alt entityâ€™de FK ve tekil navigation bulunur.
Ã–rneÄŸim: Person â†’ Addresses
Elle yazdÄ±ÄŸÄ±m kod:
public class Address : BaseEntity
{
    public AddressType AddressType { get; set; }

    [Required]
    [MaxLength(200)]
    public string Text { get; set; }

    public long PersonId { get; set; }

    [ForeignKey("PersonId")]
    public Person Person { get; set; }
}
Person sÄ±nÄ±fÄ±nda ICollection<Address> bulunur. BÃ¶ylece bir kiÅŸi birden fazla adrese sahip olabilir. Resim 1.2â€™de gÃ¶rÃ¼lmektedir.
 
3ï¸âƒ£ Ã‡oktan-bire (Many-to-One) Ä°liÅŸki
TanÄ±m:
Alt tarafta FK ve tekil navigation vardÄ±r; Ã¼st tarafta koleksiyon olabilir veya olmayabilir.
Ã–rneÄŸim: Invoice â†’ CustomerSupplier ve Invoice â†’ Current
Elle yazdÄ±ÄŸÄ±m kod:
public class Invoice : BaseEntity
{
    public InvoiceType Type { get; set; }
    public int No { get; set; }
    public DateTime Date { get; set; }
    public InvoiceSenario Senario { get; set; }

    public long CurrentId { get; set; }
    [ForeignKey("CurrentId")]
    public Current Current { get; set; }

    public long CustomerSupplierId { get; set; }
    [ForeignKey("CustomerSupplierId")]
    public CustomerSupplier CustomerSupplier { get; set; }

    public ICollection<LineOfInvoice> LineOfInvoices { get; set; } = new List<LineOfInvoice>();
}
Burada her fatura sadece bir Current ve bir CustomerSupplier ile iliÅŸkili olabilir, ancak bir Current veya CustomerSupplier birden fazla fatura ile iliÅŸkilendirilebilir. Resim 1.3â€™te gÃ¶rÃ¼lmektedir.
 
âœ… BugÃ¼nlÃ¼k Ã–zet:
â€¢	TÃ¼m entityâ€™lerde enum tipleri ve ortak alanlarÄ± kullandÄ±m.
â€¢	Bire-bir, bire-Ã§ok ve Ã§oktan-bire iliÅŸkilerin entity tarafÄ±nda nasÄ±l tanÄ±mlandÄ±ÄŸÄ±nÄ± Ã¶ÄŸrendim.
â€¢	Elle yazdÄ±ÄŸÄ±m Ã¶rnekleri kodladÄ±m ve ilgili sÄ±nÄ±flarÄ±n ekran gÃ¶rÃ¼ntÃ¼lerini aldÄ±m.
ğŸ“Œ YarÄ±n: Fluent API ile iliÅŸkileri netleÅŸtirip Map dosyalarÄ±nÄ± oluÅŸturacaÄŸÄ±m.
6. GÃœN â€“ 21 Temmuz 2025 Pazartesi
BugÃ¼n, entityâ€™lerde kurduÄŸum iliÅŸkileri Fluent API ile yazdÄ±m ve hepsini Options klasÃ¶rÃ¼ altÄ±ndaki Map dosyalarÄ±na ayÄ±rdÄ±m (Resim 1.3â€™te gÃ¶rÃ¼lmektedir).
AmaÃ§; iliÅŸki tÃ¼rlerini (1-1, 1-N, N-1) netleÅŸtirmek ve silme davranÄ±ÅŸlarÄ±nÄ± (Cascade / Restrict) doÄŸru kullanmaktÄ±.
 
Fluent APIâ€™de Ä°liÅŸkiler 
Bire-Ã§ok (1-N):
Ãœst tarafta koleksiyon, alt tarafta FK + tekil navigation.
Ã–rn: Person â†’ Addresses, Invoice â†’ LineOfInvoices
csharp
CopyEdit
builder.HasOne(a => a.Person)
       .WithMany(p => p.Addresses)
       .HasForeignKey(a => a.PersonId);
Bire-bir (1-1):
Her iki tarafta tekil navigation; FK genelde baÄŸÄ±mlÄ± tarafta.
Ã–rn: User â†” UserCredential, Bank â†” Current, Case â†” Current
csharp
CopyEdit
builder.HasOne(uc => uc.User)
       .WithOne(u => u.UserCredential)
       .HasForeignKey<UserCredential>(x => x.UserId);
Ã‡ok-tan-bire (N-1):
Alt tarafta FK + tekil navigation; Ã¼st tarafta isteÄŸe baÄŸlÄ± koleksiyon.
Ã–rn: LineOfInvoice â†’ Invoice, LineOfInvoice â†’ ProductAndService
csharp
CopyEdit
builder.HasOne(li => li.Invoice)
       .WithMany(i => i.LineOfInvoices)
       .HasForeignKey(li => li.InvoiceId);
 
Silme DavranÄ±ÅŸlarÄ±
â€¢	Cascade: Ãœst kayÄ±t silinince baÄŸlÄ± alt kayÄ±tlar da otomatik silinir.
Ã–rnek: Invoice â†’ Current (Mapâ€™te OnDelete(DeleteBehavior.Cascade) kullandÄ±m).
AyrÄ±ca satÄ±r tarafÄ±nda Invoice â†’ LineOfInvoices kurgusunda da bu mantÄ±k geÃ§erli.
â€¢	Restrict: Ãœst kayÄ±t silinmeden Ã¶nce alt kayÄ±tlarÄ±n kaldÄ±rÄ±lmasÄ± gerekir.
Ã–rnek: Invoice â†’ CustomerSupplier (Mapâ€™te OnDelete(DeleteBehavior.Restrict) kullandÄ±m).
ğŸ“Œ Kural:
â€œAlt kayÄ±t Ã¼st olmadan anlamsÄ±zsaâ€ â†’ Cascade
â€œAlt kayÄ±t korunmalÄ±/baÄŸÄ±msÄ±z kalmalÄ±ysaâ€ â†’ Restrict
 
 
MyContext SÄ±nÄ±fÄ±
Fluent API Map dosyalarÄ±nÄ± tanÄ±mladÄ±ktan sonra, Context katmanÄ±nda MyContext sÄ±nÄ±fÄ±nÄ± ekledim ve tÃ¼m Mapâ€™leri baÄŸladÄ±m.
DbSetâ€™ler, EF Coreâ€™da veritabanÄ±ndaki tablolarÄ± temsil eden koleksiyonlardÄ±r.
Bu koleksiyonlar Ã¼zerinden sorgulama, ekleme, gÃ¼ncelleme ve silme iÅŸlemleri yapÄ±lÄ±r.
        MyContext sÄ±nÄ±fÄ±mda :DbSet tanÄ±mlarÄ±, VeritabanÄ±ndaki tablolarÄ± temsil eder
        public DbSet<Address> Addresses { get; set; }
        

        protected override void OnModelCreating(ModelBuilder modelBuilder)
        {
            base.OnModelCreating(modelBuilder);

            modelBuilder.ApplyConfiguration(new AddressMap());
            modelBuilder.ApplyConfiguration(new BankMap());
            modelBuilder.ApplyConfiguration(new CaseMap());
            modelBuilder.ApplyConfiguration(new CurrentMap());
            modelBuilder.ApplyConfiguration(new CustomerSupplierMap());
            modelBuilder.ApplyConfiguration(new InvoiceMap());
            modelBuilder.ApplyConfiguration(new LineOfInvoiceMap());
            modelBuilder.ApplyConfiguration(new UserMap());
            modelBuilder.ApplyConfiguration(new UserCredentialMap());
        }
    }
}
 
âœ… BugÃ¼nlÃ¼k Ã–zet:
â€¢	TÃ¼m iliÅŸkileri Fluent API ile netleÅŸtirdim.
â€¢	Cascade / Restrict mantÄ±ÄŸÄ±nÄ± doÄŸru yerlerde uyguladÄ±m.
â€¢	Map klasÃ¶rÃ¼nÃ¼ tamamladÄ±m.
â€¢	MyContextâ€™i oluÅŸturarak tÃ¼m Mapâ€™leri baÄŸladÄ±m.
ğŸ“Œ YarÄ±n: Migrationâ€™a geÃ§erek veritabanÄ±nÄ± oluÅŸturacaÄŸÄ±m ve gerekirse seed verilerini eklemeye baÅŸlayacaÄŸÄ±m.
7. GÃœN â€“ 22 Temmuz 2025 SalÄ±
Dailyâ€™de, dÃ¼nkÃ¼ Fluent API ve MyContext Ã§alÄ±ÅŸmalarÄ±nÄ±n ardÄ±ndan bugÃ¼n SQL Server baÄŸlantÄ±sÄ± ve ilk migration iÅŸlemini yaptÄ±ÄŸÄ±mÄ± paylaÅŸtÄ±m.
AdÄ±mlarÄ±m:
â€¢	SQL Server Management Studio (SSMS) baÄŸlantÄ±sÄ±:
Ã–ncelikle SSMSâ€™i aÃ§arak localhost Ã¼zerinden Windows Authentication ile sunucuya baÄŸlandÄ±m. Bu sayede migration sonrasÄ± oluÅŸacak veritabanÄ±nÄ±n tablolarÄ±nÄ± doÄŸrudan gÃ¶rebileceÄŸim ortamÄ± hazÄ±rladÄ±m.
â€¢	Migration oluÅŸturma:
Visual Studioâ€™da Package Manager Console Ã¼zerinden:
powershell
CopyEdit
Add-Migration InitialCreate
komutunu Ã§alÄ±ÅŸtÄ±rdÄ±m. Bu komut, entityâ€™ler ve Fluent API ayarlarÄ±ma gÃ¶re tablolarÄ± oluÅŸturacak SQL scriptâ€™lerini Ã¼retti.
â€¢	VeritabanÄ±nÄ± gÃ¼ncelleme:
Migration oluÅŸturulduktan sonra:
powershell
CopyEdit
Update-Database
komutunu Ã§alÄ±ÅŸtÄ±rarak scriptâ€™leri SQL Serverâ€™a uyguladÄ±m.
â€¢	TablolarÄ±n oluÅŸumunu kontrol etme:
SSMSâ€™te InvoiceDb â†’ Tables altÄ±nda entityâ€™lerime karÅŸÄ±lÄ±k gelen tÃ¼m tablolarÄ±n eksiksiz olarak oluÅŸtuÄŸunu gÃ¶rdÃ¼m:
Addresses, Banks, Cases, Currents, CustomersSuppliers, Invoices, LineOfInvoices, Person, ProductsAndServices, UserCredentials, Users
ve ayrÄ±ca migration geÃ§miÅŸini tutan __EFMigrationsHistory tablosu.
â€¢	
ArtÄ±k kod tarafÄ±ndaki tÃ¼m model yapÄ±sÄ± SQL Server Ã¼zerinde birebir ÅŸekilde oluÅŸtu.

 
 
BugÃ¼n itibarÄ±yla DatabaseAccessLayer katmanÄ±nÄ± tamamen tamamladÄ±m. BÃ¶ylece veri tabanÄ± tarafÄ± hazÄ±r; yarÄ±n iÅŸ katmanÄ± (BusinessLogicLayer) kurulumuna geÃ§ebilirim.

 

resimde eklemiÅŸtim yazÄ±lar bÃ¶yle devamÄ±nÄ±da bu yazÄ±lara benzer ÅŸekilde yazalÄ±m ama bekle projede deÄŸiÅŸiklik yapÄ±yoruz tam bitsin Ã¶yle diÄŸer gÃ¼nleride yazarÄ±z ama ÅŸu an attÄ±klarÄ±m kesin yazdÄ±m 13 gÃ¼nlÃ¼k kÄ±smÄ± kaldÄ± onlarÄ±da proje tamamlanÄ±nca yazacaÄŸÄ±z 
